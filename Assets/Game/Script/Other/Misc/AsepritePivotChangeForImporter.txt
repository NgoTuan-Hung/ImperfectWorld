#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;
using UnityEditor.U2D.Aseprite;
using System.Collections.Generic;

public class AsepritePatcher : AssetPostprocessor
{
    // keep a short-lived set to avoid scheduling multiple times in the same import frame
    static HashSet<string> s_scheduled = new HashSet<string>();

    void OnPreprocessAsset()
    {
        if (assetImporter is AsepriteImporter ai)
            ai.OnPostAsepriteImport += OnPostAsepriteImport;
    }

    static void OnPostAsepriteImport(AsepriteImporter.ImportEventArgs args)
    {
        var importer = args.importer;
        if (importer == null)
            return;

        // If we've already marked this importer as patched, clear the mark and skip scheduling.
        // This prevents the re-import we trigger below from scheduling another patch.
        if (
            !string.IsNullOrEmpty(importer.userData)
            && importer.userData.StartsWith("AsepritePatcher:patched")
        )
        {
            importer.userData = "";
            EditorUtility.SetDirty(importer);
            AssetDatabase.WriteImportSettingsIfDirty(importer.assetPath);
            Debug.Log($"[AsepritePatcher] Clearing patch flag for {importer.assetPath}");
            return;
        }

        // schedule one delayed call (after import finishes). Use assetPath as key.
        string path = importer.assetPath;
        if (s_scheduled.Contains(path))
            return;
        s_scheduled.Add(path);

        EditorApplication.delayCall += () =>
        {
            s_scheduled.Remove(path);
            TryPatchImporter(path);
        };
    }

    static void TryPatchImporter(string assetPath)
    {
        var importer = AssetImporter.GetAtPath(assetPath) as AsepriteImporter;
        if (importer == null)
        {
            Debug.LogWarning($"[AsepritePatcher] importer null for {assetPath}");
            return;
        }

        // pick backing serialized field depending on importMode
        string fieldName = importer.importMode switch
        {
            FileImportModes.SpriteSheet => "m_SpriteSheetImportData",
            FileImportModes.TileSet => "m_TileSetImportData",
            _ => "m_AnimatedSpriteImportData",
        };

        var so = new SerializedObject(importer);
        var arrayProp = so.FindProperty(fieldName);
        if (arrayProp == null)
        {
            Debug.LogWarning(
                $"[AsepritePatcher] could not find property '{fieldName}' on importer for {assetPath}"
            );
            return;
        }

        if (arrayProp.arraySize == 0)
        {
            Debug.Log($"[AsepritePatcher] no sprites to patch in {assetPath}");
            return;
        }

        bool madeChange = false;

        for (int i = 0; i < arrayProp.arraySize; i++)
        {
            var elem = arrayProp.GetArrayElementAtIndex(i);

            // SpriteMetaData likely has fields: name, rect, alignment, pivot, border, spriteID, uvTransform
            // try both possible serialized names to be defensive
            var nameProp = elem.FindPropertyRelative("name") ?? elem.FindPropertyRelative("m_Name");
            var pivotProp =
                elem.FindPropertyRelative("pivot") ?? elem.FindPropertyRelative("m_Pivot");
            var alignmentProp =
                elem.FindPropertyRelative("alignment") ?? elem.FindPropertyRelative("m_Alignment");

            // Example change: only prefix names that haven't been prefixed yet
            if (nameProp != null)
            {
                if (!nameProp.stringValue.StartsWith("patched_"))
                {
                    nameProp.stringValue = "patched_" + nameProp.stringValue;
                    madeChange = true;
                }
            }

            // Example: set explicit custom pivot bottom-center
            if (alignmentProp != null)
            {
                if (alignmentProp.intValue != (int)SpriteAlignment.Custom)
                {
                    alignmentProp.intValue = (int)SpriteAlignment.Custom;
                    madeChange = true;
                }
            }

            if (pivotProp != null)
            {
                Vector2 want = new Vector2(0.5f, 0f);
                // serialized Vector2 is stored in vector2Value
                if (pivotProp.vector2Value != want)
                {
                    pivotProp.vector2Value = want;
                    madeChange = true;
                }
            }
        }

        if (!madeChange)
        {
            Debug.Log($"[AsepritePatcher] nothing to change for {assetPath}");
            return;
        }

        // Save modified serialized props back to importer
        so.ApplyModifiedProperties();
        EditorUtility.SetDirty(importer);

        // Mark importer so the re-import we trigger doesn't re-run the patch endlessly.
        importer.userData = "AsepritePatcher:patched";
        EditorUtility.SetDirty(importer);

        // Persist settings and trigger one reimport so Unity recreates sprite sub-assets with new names/pivots.
        AssetDatabase.WriteImportSettingsIfDirty(assetPath);
        AssetDatabase.ImportAsset(assetPath, ImportAssetOptions.ForceUpdate);

        Debug.Log($"[AsepritePatcher] patched and reimported {assetPath}");
    }
}
#endif


---------------------------------Working Code
using UnityEditor;
using UnityEditor.U2D.Aseprite;
using UnityEngine;

public class GameObjectInjector : AssetPostprocessor
{
    void OnPreprocessAsset()
    {
        if (assetImporter is AsepriteImporter aseImporter)
            aseImporter.OnPostAsepriteImport += OnPostAsepriteImport;
    }

    static AsepriteImporter.ImportEventArgs myArgs;
    public static BoolSO boolSO;

    static void OnPostAsepriteImport(AsepriteImporter.ImportEventArgs args)
    {
        boolSO = Resources.Load<BoolSO>("Misc/BoolSO");
        if (boolSO.value)
            return;
        myArgs = args;
        EditorApplication.delayCall += Delay;
    }

    static void Delay()
    {
        EditorApplication.delayCall -= Delay;
        var importer = myArgs.importer;
        var assetPath = myArgs.importer.assetPath;

        // pick backing serialized field depending on importMode
        string fieldName = importer.importMode switch
        {
            FileImportModes.SpriteSheet => "m_SpriteSheetImportData",
            FileImportModes.TileSet => "m_TileSetImportData",
            _ => "m_AnimatedSpriteImportData",
        };

        var so = new SerializedObject(importer);
        var arrayProp = so.FindProperty(fieldName);
        if (arrayProp == null)
        {
            Debug.LogWarning(
                $"[AsepritePatcher] could not find property '{fieldName}' on importer for {assetPath}"
            );
            return;
        }

        if (arrayProp.arraySize == 0)
        {
            Debug.Log($"[AsepritePatcher] no sprites to patch in {assetPath}");
            return;
        }

        bool madeChange = false;

        for (int i = 0; i < arrayProp.arraySize; i++)
        {
            var elem = arrayProp.GetArrayElementAtIndex(i);

            // SpriteMetaData likely has fields: name, rect, alignment, pivot, border, spriteID, uvTransform
            // try both possible serialized names to be defensive
            var nameProp = elem.FindPropertyRelative("name") ?? elem.FindPropertyRelative("m_Name");
            var pivotProp =
                elem.FindPropertyRelative("pivot") ?? elem.FindPropertyRelative("m_Pivot");
            var alignmentProp =
                elem.FindPropertyRelative("alignment") ?? elem.FindPropertyRelative("m_Alignment");

            // Example change: only prefix names that haven't been prefixed yet
            if (nameProp != null)
            {
                if (!nameProp.stringValue.StartsWith("patched_"))
                {
                    nameProp.stringValue = "patched_" + nameProp.stringValue;
                    madeChange = true;
                }
            }

            // Example: set explicit custom pivot bottom-center
            if (alignmentProp != null)
            {
                if (alignmentProp.intValue != (int)SpriteAlignment.Custom)
                {
                    alignmentProp.intValue = (int)SpriteAlignment.Custom;
                    madeChange = true;
                }
            }

            if (pivotProp != null)
            {
                Vector2 want = new Vector2(0.5f, 0f);
                // serialized Vector2 is stored in vector2Value
                if (pivotProp.vector2Value != want)
                {
                    pivotProp.vector2Value = want;
                    madeChange = true;
                }
            }
        }

        if (!madeChange)
        {
            Debug.Log($"[AsepritePatcher] nothing to change for {assetPath}");
            return;
        }

        // Save modified serialized props back to importer
        so.ApplyModifiedProperties();
        EditorUtility.SetDirty(importer);

        // Persist settings and trigger one reimport so Unity recreates sprite sub-assets with new names/pivots.
        AssetDatabase.WriteImportSettingsIfDirty(assetPath);
        AssetDatabase.ImportAsset(assetPath, ImportAssetOptions.ForceUpdate);

        Debug.Log($"[AsepritePatcher] patched and reimported {assetPath}");
    }
}
